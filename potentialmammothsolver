import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report, confusion_matrix

from anagram import anagrams_of, filter_real_words as anagram_filter
from hidden import ngrams_of, filter_real_words as hidden_filter
from selector import generate_all_selectors, filter_real_words as selector_filter

df = pd.read_csv("logistic_data.csv")

df["fodder_length"] = (
    df["fodder"].astype(str)
    .str.replace(r"[^A-Za-z]", "", regex=True)
    .str.len()
)

df["fodder_word_count"] = df["fodder"].astype(str).str.split().apply(len)

X = df[[
    "length",
    "fodder_length",
    "fodder_word_count"
]].values.astype(float)

y_raw = df["category"].values
label_encoder = LabelEncoder()
y = label_encoder.fit_transform(y_raw)

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.4, stratify=y, random_state=42
)

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

logreg = LogisticRegression(
    multi_class="multinomial",
    solver="lbfgs",
    max_iter=500
)
logreg.fit(X_train_scaled, y_train)

print("\n=== Classification Report ===")
y_pred = logreg.predict(X_test_scaled)
print(classification_report(y_test, y_pred, target_names=label_encoder.classes_))
print("\n=== Confusion Matrix ===")
print(confusion_matrix(y_test, y_pred))


def extract_features(clue, indicator, length, fodder, definition):
    fod_clean_len = len("".join([c for c in str(fodder) if c.isalpha()]))
    return np.array([[float(length), float(fod_clean_len), len(str(fodder).split())]])


def predict_category(clue, indicator, length, fodder, definition):
    x = extract_features(clue, indicator, length, fodder, definition)
    x_scaled = scaler.transform(x)
    pred_id = logreg.predict(x_scaled)[0]
    pred_label = label_encoder.inverse_transform([pred_id])[0]
    pred_probs = logreg.predict_proba(x_scaled)[0]
    return pred_label, pred_probs


def solve_anagram(fodder, length):
    all_words = anagrams_of(fodder)
    real = anagram_filter(all_words)
    return {w for w in real if len(w) == length}


def solve_hidden(fodder, length):
    grams = ngrams_of(length, fodder)
    return hidden_filter(grams)


def solve_selector(fodder, length):
    cands = generate_all_selectors(fodder, length)
    return selector_filter(cands)


print("\n=== Solve a New Clue ===")
clue = input("Enter the clue: ")
indicator = input("Enter the indicator: ")
fodder = input("Enter the fodder words: ")
definition = input("Enter the definition: ")

while True:
    try:
        length = int(input("Enter solution length: "))
        break
    except:
        print("Length must be an integer.")

pred_label, pred_probs = predict_category(
    clue, indicator, length, fodder, definition
)

print("\n=== Category Prediction ===")
print("Predicted Category:", pred_label)
print("\nProbabilities:")
for cat, p in zip(label_encoder.classes_, pred_probs):
    print(f"  {cat}: {p:.4f}")

print("\n=== Solutions ===")
if pred_label == "Anagrams":
    sol = solve_anagram(fodder, length)
elif pred_label == "Hiddens":
    sol = solve_hidden(fodder, length)
elif pred_label == "Selectors":
    sol = solve_selector(fodder, length)
else:
    sol = set()

print(sol if sol else "No English word candidates found.")
